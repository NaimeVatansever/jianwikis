#summary A* Algorithm for Path Planning.
#labels Phase-Implementation

= Introduction =

Recently, I work on a warehouse optimization project. On interesting problem is to select an optimal pick tour for the pick agent, which is very much like a simplified path planning problem in a game world. I used the popular [http://en.wikipedia.org/wiki/A*_search_algorithm A`*` search algorithm] and like to share with you about my Java implementation of the A`*` algorithm.

= Java Implementation =

== Data Structure ==

To use the A`*` algorithm, I need to define a Graph data structure as follows.

=== Node ===

A node is a vertex of the graph.

{{{
public class Node {

    protected String id;
}
}}}

=== Edge ===

{{{
public class Edge {

    protected String from;

    protected String to;

}
}}}

=== Adjacency ===

Adjacency is used to represent the neighbours of the current node.

{{{
public class Adjacency<N extends Node>{
    protected N node;
    protected Set<N> neighbors;
}
}}}

=== Graph ===

A graph can be defined as follows. Note, the edgeList and adjacency may be redundant and you can use one of them in your application.
 
{{{
public class Graph<N extends Node, E extends Edge> {

    protected List<N> nodeList;
    
    protected List<E> edgeList;
    
    //Index for fast access
    private Map<String, Adjacency<N>> adjacency;

    //directed graph or not
    protected boolean diGraph;
}
}}}

== Navigation Graph ==

In the warehouse application, we need to build a navigation graph to help us to construct the path for the pick agent. In a tiled environment, you can first use the [http://en.wikipedia.org/wiki/Flood_fill Flood Fill algorithm] to search for the connection in the application world. Then build a navigation graph based on it. For our warehouse application, we can create outlines for aisles to obtain a navigation graph.

The navigation graph is defined as follows.

{{{
public class NavNode extends Node{

    protected Position position;

    protected List<String> extraData;

}}}

public class NavEdge extends Edge {

    protected double cost;
}

public class NavGraph extends Graph<NavNode, NavEdge>{

    //NavGraph is bidirectional, one connection consists of two edges
    public void addConnection(String firstId, String secondId){
        NavNode node1 = this.getNode(firstId);
        NavNode node2 = this.getNode(secondId);
        if(node1 != null && node2 != null){
            double cost = this.calcManhattanDistance(node1, node2);
            NavEdge edge1 = new NavEdge(firstId, secondId, cost);
            NavEdge edge2 = new NavEdge(secondId, firstId, cost);
            this.addEdge(edge1);
            this.addEdge(edge2);
        }
    }

    public void removeConnection(String firstId, String secondId){
        NavEdge edge1 = new NavEdge(firstId, secondId);
        NavEdge edge2 = new NavEdge(secondId, firstId);
        this.removeEdge(edge1);
        this.removeEdge(edge2);
    }

    public double calcManhattanDistance(NavNode a, NavNode b){
        return abs(a.getPosition().getX() - b.getPosition().getX())
                + abs(a.getPosition().getY() - b.getPosition().getY());
    }
}
}}}

In our application, we choose to use the Manhatten distance. 

